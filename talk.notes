

----------------------------------------------------------------------
"Introduce myself"

My name.
School with Mr. Greaves
Manchester University
I work as a software engineer.

----------------------------------------------------------------------
"A day with programming is a day wasted"

Love programming.
This talk will Sowshow some links between maths and programming.

Take as our main example, a sequence of numbers you may be familiar with.

----------------------------------------------------------------------
"Fibonacci Sequence"

Who has seen or heard of this before?
See the pattern?


----------------------------------------------------------------------
"Rule for the next elemnt of the sequence"

Each element is computed by adding the two numbers before it.
Starting with 0,1 (or sometimes people start at 1,1)
fib(1) = 1, fib(2) = 1, fib(3) = 2.... fib(5) = 5, fib(6) = 8 ...

Discovered/Invented in 1202s by "Fibonacci"
while he investigated a problem about how fast rabbits breed!

There are lots of intersting things related to the fibonacci sequence
Today we are going to focus on the ration between successive elemets of the sequence.
What do I mean by this?

----------------------------------------------------------------------
"Ratio sequence"

ratio of successive terms... 1,1 then 1,2 then 3,2...
the second term is alway bigger that the first, so answer bigger that 1
not sequence of fractions... starts bouncing: 1, 2, 1&1/2, 1&2/3
then seems too start settling down.

Does it ever reach a particular numbers?...
Anyone know?

----------------------------------------------------------------------
"Golden ratio" 1.618...

Answer is yes. but it's not a nice simple number.
If you write it out in decimal you will never reach the end of the digits.
Anyone know another number like this?... PI
And like Pi, the golden ration is regarded as very special.
A constant of nature.
And becuse it's so special, like PI, it has a name & a symbol...

----------------------------------------------------------------------
"Phi symbol"

Phi. (spelt P.H.I, pronounced with an F) looks like this.. or this...

"Another Phi symbol"
"Phi Ring"

Why do people care about Phi?
Some people think this ration crops up throughout nature...

----------------------------------------------------------------------
"Spiral numbers"
"Shell"
"Sunflower"
"Plant"
"Galaxy"

and art...

----------------------------------------------------------------------
"Mona lisa"
"Donald"

- gettting a bit silly

----------------------------------------------------------------------
"Phi value again"
phi = 1.618...

Summary. This is the value of the golden ratio.
The ratio between successiive terms of the fib sequence. (Or multiplicative factor.)

Anyway. Lets get back to the Fibonacci sequence itself...
(from which the golden ration is generated)
First. Lets recap how it is generated

----------------------------------------------------------------------
"Maths seq rule"

subscripts mean element number in the sequence.

Anything missing?
basecase!

----------------------------------------------------------------------
"First 29"

10th... 55
20th... 6765

so... how would we go about calculating more and more terms of this sequence
say I want the... 200th element.

Could we do that on paper?
How long would it take us?
Do you think we could do it without making mistakes?
Probably not.
And it would be pretty tedious.

So, what else could we do?....

Of course write a program!

----------------------------------------------------------------------
"a wasted day again"

open python interpreter

one way of thinking about programming is evaluating functions
basic functions are already available to us; but we can define new functions too
what is a function?

----------------------------------------------------------------------
"Trivial (x2) function example"
"General function machine"
or... question -> answer machine.

Might remember simple function machines.. such as x2
But in general functions can do anything.
Inputs to outputs.
Can take more than one input. addition is a function from two numbers, to a result.

run examples in interpreter: + etc
explain fib is a function too. From position in sequence to value: 5 -> 5, 10 -> 55 etc

code fib (TODO: code with two basecases? 0/1 or 1/1 ?)
talk about base cases & recursion

load in interpreter: test: fib: 10, 20,30 etc
code loop. (TODO: upto exactly what value?)

slow; not good;
who wants to wait?
who thinks we'll get to 200 if we wat long enough?

how slow? timings - explain time... diffs
make loop be self timing.
anyone notice anything about times?...

confim ratio between terms 5 part, 10 apart...
make prediction for future term (TODO: which one -- want it to be about 20 second)
TODO: how to easily run/time just that one value
confirm matches prediction!

ok, now look at time for fib(50), fib(100) etc

old notes...

    hmm,
    just how slow is it getting

    add time
    -- number of seconds since 1st Jan 1970. unix clocks!
    - no problem, duration is just the difference between two times.

    add two time calls and print to the loop.

    hmm, now we can see how bad the slowdown is more objectively...
    anyone see a pattern...
    is it getting slower by an additive factor...
    or a multiplicative factor...?

    lets do some sums...

    fib(20) / fib(15)
    fib(25) / fib(20)
    fib(30) / fib(25)

    expect to see about 11.

    turns out this is phi^5
    calculator.

    each extra step is a factor of phi = 1.6...

    any multiplicative factor is bad.
    if the factor is 2, this would mean that each step take twce the tiem of the prev
    1.6 is not so bad, but still it's pretty devistating.

    lets do an estimate

    fib(35) takes?
    so for fib(4), multiply by 11... get ?
    actually measure... wow, very close!

    so what about fib(50)... x11 x11

    what about fib(100).... millions of years
    crazy

    what about fib(200) ???
    will it even compute before life on earth ends?

----------------------------------------------------------------------
"Sun in 7 billion years"

so fib(100) takes x million years
we have loads more time than this... y thousand times more

how many more steps can we do in this 1000x more time?
well, no many!
because we have a multiplicative factor
we know phi^5 is 11
phi^10 is 123

so phi^17 is y000 ish

so we get to 117 steps before the sun consumes the earth


hmm, something is not right here!
clearly there is something very wrong with our program

when we thought about doing the fib calc by hand
we imagined a very simple process
keep adding pair of numbers to get the next number

----------------------------------------------------------------------
"Addition rule many steps"

but clearly that is not what our program is doing.

think in terms of questions and answers..

questions are either base case, or ask more questsions...
but the program keeps asking the same questions
that is what cause the multiplicative factor

and causes the runtime of our program to become exponential

----------------------------------------------------------------------
"fib(5) tree picture"

talk about it (TODO: can I find an even better picture)


----------------------------------------------------------------------
"a day wasted"

ok, so fix our program....

code loop... compare values... run.. quick!

----------------------------------------------------------------------
"summary"

As well as writing programs to compute mathmatical functions

We can use mats to think about our programs. In particular, how long they will take to run

There is a whole branch of computer science dedicated to thinking about this
called "Complexity Theory"

What I wanted to demonstrate to you today is that if you have an algorithm with bad complexity
And in this case we say the complexity is "exponential"
It really doesn't matter how fast your computer is, or how long you wait.
Very soon you will reach a value you cannot compute.

But if you write a better algorithm (in our case the revised algorithm is "Linear")
Then computers allow us to compute enormous things very quickly
